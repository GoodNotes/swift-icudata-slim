#!/usr/bin/env python3

import argparse
import json
import os
import shutil
import subprocess
import sys
import tempfile
from pathlib import Path

ICU_VERSIONS_FILE = Path(__file__).parent.parent / "icu-versions.json"


def parse_args():
    parser = argparse.ArgumentParser(description="Package ICU data as a C source file for Swift Foundation.")
    parser.add_argument("--swift-version", help="Swift version (e.g., 6.2)")
    parser.add_argument("--icu-version", help="ICU version (e.g., 74.1)")
    parser.add_argument("--filter-json", required=True, help="Path to ICU data filter JSON file")
    parser.add_argument("--output", required=True, help="Output C source file path")
    parser.add_argument("--build-dir", default=str(Path(__file__).parent.parent / ".build" / "icu"), help="Output build directory path")
    parser.add_argument("--jobs", type=int, default=os.cpu_count(), help="Number of parallel jobs for make")
    return parser.parse_args()


# Load ICU version and source URL from the JSON file and CLI arguments
def load_icu_info(args):
    if args.swift_version and args.icu_version:
        raise ValueError("Cannot specify both --swift-version and --icu-version")
    if not args.swift_version and not args.icu_version:
        raise ValueError("Must specify either --swift-version or --icu-version")
    with open(ICU_VERSIONS_FILE) as f:
        versions = json.load(f)

    if args.swift_version:
        icu_version = versions["swift-icu-versions"][args.swift_version]
    else:
        icu_version = args.icu_version
    return icu_version, versions["icu-source"][icu_version]


def download_and_extract(url, dest_dir, icu_version):
    cache_dir = dest_dir / icu_version
    cache_dir.mkdir(parents=True, exist_ok=True)
    tarball = cache_dir / "icu.tar.gz"
    if not tarball.exists():
        print(f"Downloading ICU from {url}...")
        subprocess.run(["curl", "-L", "-o", str(tarball), url], check=True)
    else:
        print(f"[cache] Using cached ICU source for {icu_version} at {tarball}")

    source_dir = cache_dir / "src"
    if not source_dir.exists():
        print(f"Extracting ICU source...")
        source_dir.mkdir(parents=True, exist_ok=True)
        subprocess.run(["tar", "xf", str(tarball), "-C", str(source_dir), "--strip-components=1"], check=True)
    return source_dir


def build_icu(icu_src, filter_json, jobs, destdir):
    build_dir = icu_src / "icu4c/source"
    # Copy filter file into build_dir
    config_env = os.environ.copy()
    config_env["ICU_DATA_FILTER_FILE"] = str(filter_json)
    install_dir = destdir / "usr/local"
    print(f"Configuring ICU...")
    subprocess.run([
        str(build_dir / "configure"), "--prefix=" + str(install_dir), "--with-data-packaging=archive"
    ], cwd=build_dir, check=True, env=config_env)
    print(f"Building ICU...")
    subprocess.run(["make", f"-j{jobs}"], cwd=build_dir, check=True)
    print(f"Installing ICU...")
    subprocess.run(["make", "install", f"DESTDIR={destdir}"], cwd=build_dir, check=True)
    # Recursively search for the .dat file
    for root, dirs, files in os.walk(destdir):
        for file in files:
            if file.startswith("icudt") and file.endswith("l.dat"):
                dat_path = Path(root) / file
                version = dat_path.parent.name
                return dat_path, version
    raise RuntimeError("ICU .dat file not found after build.")

def human_readable_size(size):
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size < 1024.0:
            return f"{size:.2f} {unit}"
        size /= 1024.0
    return f"{size:.2f} PB"

def dat_to_c(dat_path, version, output_path):
    major = version.split(".")[0]
    entry_point = f"icudt{major}_dat"
    print(f"ICU data size: {human_readable_size(os.path.getsize(dat_path))} ({dat_path})")

    os.makedirs(os.path.dirname(output_path), exist_ok=True)

    # Copy the .dat file to the output directory
    shutil.copy(dat_path, os.path.join(os.path.dirname(output_path), os.path.basename(dat_path)))

    # Write C file using #embed directive
    with open(output_path, "w") as out:
        out.write(f"// Generated by package-icudata.py\n")
        out.write(f"#include <stdint.h>\n")
        out.write(f"#pragma clang diagnostic ignored \"-Wc23-extensions\"\n")
        out.write(f"#ifdef __cplusplus\nextern \"C\" {{\n#endif\n")
        out.write(f"__attribute__((aligned(16))) const uint8_t {entry_point}[] = {{\n")
        out.write(f"#embed \"{os.path.basename(dat_path)}\"\n")
        out.write(f"}};\n")
        out.write(f"#ifdef __cplusplus\n}}\n#endif\n")
    print(f"C source file written to {output_path}")


def main():
    args = parse_args()
    icu_version, icu_url = load_icu_info(args)
    build_dir = Path(args.build_dir)
    icu_src = download_and_extract(icu_url, build_dir, icu_version)
    destdir = build_dir / "destdir"
    destdir.mkdir(parents=True, exist_ok=True)
    dat_path, version = build_icu(icu_src, Path(args.filter_json).absolute(), args.jobs, destdir)
    dat_to_c(dat_path, version, args.output)

if __name__ == "__main__":
    main()
